/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#include "Trigonometric.h"
#include "Arithmetic.h"
#include "TADPilaDin.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

void Menu();
void Postfijo(char *expresion);
void Prefijo(char* expresion);
char *ConvertirInfijoPostfijo(char *expresion);
int Parentesis(char *cadena);
char *InvertirCadena(char *cadena);
float FunctTrigonometricas(char *funct, elemento operando1);
float FunctAritmeticas(char simbolo, elemento operando1, elemento operando2);

char *host;

int main (int argc, char *argv[])
{
	char expresion[256];
	int opcion;
	host = argv[1];

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}

	while(1){
		Menu();
		printf("Seleccione una opcion: ");
		scanf("%d", &opcion);

		if(opcion<4 && opcion>0){
			printf("\nExpresion: ");
			scanf("%s", expresion);
		}

		switch(opcion){
			case 1: Prefijo(expresion); getchar(); getchar(); break;
			case 2: Postfijo(expresion); getchar(); getchar(); break;
			case 3: Postfijo(ConvertirInfijoPostfijo(expresion)); getchar(); getchar(); break;
			case 4: exit(0);
			default: printf("Opcion invalida\n"); getchar(); getchar(); break;
		}
	}
}

void Menu()
{
	printf("\n");
	printf("_____________________________________________\n");
	printf("|           -OPERACIONES VALIDAS-           |\n");
	printf("| Suma: +                   Seno: sin       |\n");
	printf("| Resta: -                  Coseno: cos     |\n");
	printf("| Multiplicacion: *         Tangente: tan   |\n");
	printf("| Division: /               Cotangente: ctg |\n");
	printf("| Exponenciacion: ^         Secante: sec    |\n");
	printf("| Logaritmo: log            Cosecante: csc  |\n");
	printf("| Raiz Cuadrada: sqrt                       |\n");
	printf("|___________________________________________|\n");

	printf("\n");
	printf("------------OPCIONES------------\n");
	printf("1. Evaluar expresion prefija\n");
	printf("2. Evaluar expresion postfija\n");
	printf("3. Evaluar expresion infija\n");
	printf("4. Salir\n");
	printf("\n");
}

void Postfijo(char *expresion)
{
	elemento e, operando1, operando2;
	pila stack;
	char *expr;

	expr = (char*)malloc(sizeof(expresion)*sizeof(char));
	strcpy(expr, expresion);
	//printf("%s\n", expr);
	Initialize(&stack);

	for(int i=0; i<strlen(expr); i++){
		if(isdigit(expr[i])){
			char numero[50];
			int k=0;

			while(expr[i]=='.' || isdigit(expr[i])){
				numero[k] = expr[i];
				i++; k++;
			}

			e.f = (float)atof(numero);
			Push(&stack, e);
			memset(numero,0,k);
			i--;
		}
		else if(islower(expr[i])){
			char funct[4];
			int j=i, k=0;

			while(islower(expr[j]) && k<4){
				funct[k] = expr[j];
				j++; k++;
			}

			//printf("Inglaterra del sur");
			operando1 = Pop(&stack);
			e.f = FunctTrigonometricas(funct, operando1);

			if(!strncmp(funct, "sqrt", 4))
				i= i+3;
			else
				i= i+2;

			Push(&stack, e);
		}
		else if(ispunct(expr[i])){
			if(expr[i]==',')
				continue;
			else{
				operando2 = Pop(&stack);
				operando1 = Pop(&stack);
				e.f = FunctAritmeticas(expr[i], operando1, operando2);
				Push(&stack, e);
			}
		}
		else{
			printf("ERROR: Expresion no valida");
			exit(1);
		}
	}

	e = Pop(&stack);
	printf("----RESULTADO= %f----\n", e.f);
	free(expr);
}

void Prefijo(char* expresion){
	elemento e, operando1, operando2;
	pila stack;
	char *expr;
	int i;

	expr = (char*)malloc(sizeof(expresion)*sizeof(char));
	strcpy(expr, expresion);
	Initialize(&stack);

	for(i=strlen(expr)-1; i>=0; i--){
		if(isdigit(expr[i])){
			char aux[50], numero[50];
			int k=0;
			memset(aux,0,50);
			memset(numero,0,50);

			while(expr[i]=='.' || isdigit(expr[i])){
				aux[k] = expr[i];
				i--; k++;
			}

			strcpy(numero, InvertirCadena(aux));
			e.f = (float)atof(numero);
			Push(&stack, e);
			i++;
		}
		else if(islower(expr[i])){
			char aux2[4], funct[4];
			int j=i, k=0;
			memset(aux2,0,4);
			memset(funct,0,4);

			while(islower(expr[j]) && k<4){
				aux2[k] = expr[j];
				j--; k++;
			}

			strcpy(funct, InvertirCadena(aux2));
			operando1 = Pop(&stack);
			e.f = FunctTrigonometricas(funct, operando1);
			Push(&stack, e);

			if(!strncmp(funct, "sqrt", 4))
				i= i-3;
			else
				i= i-2;
		}
		else if(ispunct(expr[i])){
			if(expr[i]==',')
				continue;
			else{
				operando1 = Pop(&stack);
				operando2 = Pop(&stack);
				e.f = FunctAritmeticas(expr[i], operando1, operando2);
				Push(&stack, e);
			}
		}
		else{
			printf("ERROR: Expresion no valida");
			exit(1);
		}
	}

	e = Pop(&stack);
	printf("----RESULTADO= %f----\n", e.f);
	free(expr);
}

char *ConvertirInfijoPostfijo(char *expresion)
{
	char *expr, postfijo[256];
	pila stack;
	elemento e, e2, aux;
	int j=0, prioridad=0, prior;

	expr = (char*)malloc(sizeof(expresion)*sizeof(char));
	strcpy(expr, expresion);
	Initialize(&stack);

	if(!Parentesis(expr)){
		printf("ERROR: Orden de parentesis anidados no valido");
		exit(1);
	}

	for(int i=0; i<strlen(expr); i++){
		if(isdigit(expr[i])){
			while(expr[i]=='.' || isdigit(expr[i])){
				postfijo[j] = expr[i];
				i++; j++;
			}

			postfijo[j] = ',';
			i--; j++;
		}
		else if(islower(expr[i])){
			char funct[4];
			int j=i, k=0;

			while(islower(expr[j]) && k<4){
				funct[k] = expr[j];
				j++; k++;
			}

			prioridad = 3;
			strcpy(e2.str, funct);
			Push(&stack, e2);

			if(!strncmp(funct, "sqrt", 4))
				i= i+3;
			else
				i= i+2;
		}
		else if(ispunct(expr[i])){
			e.c = expr[i];

			if(expr[i]=='('){
				Push(&stack, e);
				prioridad=0;
			}
			else if(expr[i]==')'){
				aux = Top(&stack);

				while(aux.c!='('){
					e = Pop(&stack);

					if(strlen(e.str)>0){
						for(int x=0; x<strlen(e.str); x++){
							postfijo[j] = e.str[x];
							j++;
						}
					}
					else{
						postfijo[j] = e.c;
						j++;
					}

					postfijo[j] = ',';
					j++;
					aux = Top(&stack);
				}

				Pop(&stack);//saca el parentesis '('
				
				if(!Empty(&stack)){
					aux = Top(&stack);
					if(aux.c=='^')
						prioridad = 2;
					else if(aux.c=='*' || aux.c=='/')
						prioridad = 1;
					else if(aux.c=='+' || aux.c=='-')
						prioridad = 0;
					else
						prioridad = 3;
				}
			}
			else{
				if(expr[i]=='^')
					prior = 2;
				else if(expr[i]=='*' || expr[i]=='/' )
					prior = 1;
				else if(expr[i]=='+' || expr[i]=='-' )
					prior = 0;
				else{
					printf("ERROR: Simbolo invalido");
					exit(1);
				}

				if(prior>=prioridad){
					prioridad = prior;
					Push(&stack, e);
				}
				else{
					do{
						aux = Pop(&stack);

						if(strlen(aux.str)>0){
							for(int x=0; x<strlen(aux.str); x++){
								postfijo[j] = aux.str[x];
								j++;
							}
						}
						else{
							postfijo[j] = aux.c;
							j++;
						}

						postfijo[j] = ',';
						j++;

						if(!Empty(&stack))
							aux = Top(&stack);
					}while(!Empty(&stack) && aux.c!='(');

					Push(&stack, e);
					if(e.c=='^')
						prioridad = 2;
					else if(e.c=='*' || e.c=='/' )
						prioridad = 1;
					else
						prioridad = 0;
				}	
			}	
		}
		else{
			printf("ERROR: Expresion no valida");
			exit(1);
		}
	}

	if(!Empty(&stack)){
		do{
			e = Pop(&stack);

			if(strlen(e.str)>0){
				for(int x=0; x<strlen(e.str); x++){
					postfijo[j] = e.str[x];
					j++;
				}
			}
			else{
				postfijo[j] = e.c;
				j++;
			}

			if(Size(&stack)==0)
				postfijo[j] = '\0';
			else
				postfijo[j] = ',';
			j++;
		}while(!Empty(&stack));
	}

	//printf("%s\n", postfijo);
	strcpy(expresion, postfijo);
	return expresion;
}

int Parentesis(char *cadena)
{
	pila stack;
	elemento e;
	Initialize(&stack);

	for(int i=0; i<strlen(cadena); i++){
		if(cadena[i]=='('){
			e.c = cadena[i];
			Push(&stack, e);
		}
		else if(cadena[i]==')'){
			if(Empty(&stack))
				return 0;
			else
				e = Pop(&stack);
		}
	}

	if(!Empty(&stack))
		return 0;
	else{
		Destroy(&stack);
		return 1;
	}
}

char *InvertirCadena(char *cadena)
{
	int longitud = strlen(cadena);
	char temp;

	for(int i=0, j=longitud-1; i<(longitud/2); i++, j--){
		temp = cadena[i];
		cadena[i] = cadena[j];
		cadena[j] = temp;
	}

	return cadena;
}

float FunctTrigonometricas(char *funct, elemento operando1)
{
	CLIENT *clnt;
	float *result;
	float operando = operando1.f;

	#ifndef DEBUG
		clnt = clnt_create(host, TRIGONOMETRIC_PRG, TRIGONOMETRIC_VER, "udp");
		if(clnt==NULL){
			clnt_pcreateerror(host);
			exit(1);
		}
	#endif

	if(!strncmp(funct, "sin", 3)){
		result = seno_1(&operando, clnt);

		if(result==(float*)NULL)
			clnt_perror(clnt, "call failed");
	}
	else if(!strncmp(funct, "cos", 3)){
		result = coseno_1(&operando, clnt);

		if(result==(float*)NULL)
			clnt_perror(clnt, "call failed");		
	}
	else if(!strncmp(funct, "tan", 3)){
		result = tangente_1(&operando, clnt);

		if(result==(float*)NULL)
			clnt_perror(clnt, "call failed");
		}
	else if(!strncmp(funct, "ctg", 3)){
		result = cotangente_1(&operando, clnt);

		if(result==(float*)NULL)
			clnt_perror(clnt, "call failed");
	}
	else if(!strncmp(funct, "sec", 3)){
		result = secante_1(&operando, clnt);

		if(result==(float*)NULL)
			clnt_perror(clnt, "call failed");
	}
	else if(!strncmp(funct, "csc", 3)){
		result = cosecante_1(&operando, clnt);

		if(result==(float*)NULL)
			clnt_perror(clnt, "call failed");
	}
	else if(!strncmp(funct, "log", 3)){
		result = logaritmo_1(&operando, clnt);

		if(result==(float*)NULL)
			clnt_perror(clnt, "call failed");
	}
	else if(!strncmp(funct, "sqrt", 4)){
		result = raizcuadrada_1(&operando, clnt);

		if(result==(float*)NULL)
			clnt_perror(clnt, "call failed");
	}
	else{
		printf("ERROR: Expresion no valida");
		exit(1);
	}

	#ifndef DEBUG
		clnt_destroy(clnt);
	#endif

	return *result;
}


float FunctAritmeticas(char simbolo, elemento operando1, elemento operando2)
{
	CLIENT *clnt;
	float *result;
	operandos op;

	op.operando1 = operando1.f;
	op.operando2 = operando2.f;

	#ifndef DEBUG
		clnt = clnt_create(host, ARITHMETIC_PRG, ARITHMETIC_VER, "udp");
		if(clnt==NULL){
			clnt_pcreateerror(host);
			exit(1);
		}
	#endif

	//printf("Operando1: %f\n", operando1.f);
	//printf("Operando2: %f\n", operando2.f);

	switch(simbolo){
		case '^':
			result = exponencial_1(&op, clnt);

			if(result==(float*)NULL)
				clnt_perror(clnt, "call failed");
			break;
		case '/':
			result = division_1(&op, clnt);

			if(result==(float*)NULL)
				clnt_perror(clnt, "call failed");
			break;
		case '*':
			result = multiplicacion_1(&op, clnt);

			if(result==(float*)NULL)
				clnt_perror(clnt, "call failed");
			break;
		case '-':
			result = resta_1(&op, clnt);

			if(result==(float*)NULL)
				clnt_perror(clnt, "call failed");
			break;
		case '+':
			result = suma_1(&op, clnt);

			if(result==(float*)NULL)
				clnt_perror(clnt, "call failed");
			break;
		default: printf("ERROR: Expresion no valida"); exit(1);
	}

	#ifndef DEBUG
		clnt_destroy(clnt);
	#endif

	return *result;
}
